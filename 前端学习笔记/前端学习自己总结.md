## 一、前端核心技术基石

### 1. HTML（超文本标记语言）

- 核心作用

  ：负责页面的结构搭建，通过标签定义不同类型的内容。

  - 基础标签示例：`<h1>`-`<h6>`（标题，从大到小）、`<p>`（段落）、`<div>`（通用容器，无特定语义）。

- 重点掌握

  ：语义化标签的使用

  - 常用语义化标签：`<header>`（页头）、`<nav>`（导航）、`<main>`（页面主体）、`<article>`（独立文章内容）、`<footer>`（页脚）等。
  - 作用：提升页面可读性（便于开发者维护）和 SEO 友好度（帮助搜索引擎理解页面结构）。

- 常见问题

  ：标签嵌套规则

  - 块级元素（如`<div>`、`<p>`、`<h1>`）可包含行内元素（如`<span>`、`<a>`、`<strong>`）。
  - 行内元素通常不能包含块级元素（特殊情况除外，如`<a>`标签可包含块级元素）。

### 2. CSS（层叠样式表）

- **核心作用**：用于美化页面，控制元素的布局、颜色、字体等样式。

- 核心知识点

  ：

  - 选择器：类选择器（`.classname`）、ID 选择器（`#idname`）、后代选择器（`父元素 子元素`）、子代选择器（`父元素>子元素`）、伪类选择器（`:hover`、`:active`等）。
  - 盒模型：每个元素都可视为一个盒子，由内到外包括`content`（内容区）、`padding`（内边距）、`border`（边框）、`margin`（外边距）。
  - 浮动与清除浮动：
    - 浮动（`float: left/right`）：让元素脱离文档流，向左 / 右浮动，常用于早期布局。
    - 问题：浮动元素可能导致父元素高度塌陷。
    - 清除浮动方法：添加空标签并设置`clear: both`、父元素设置`overflow: hidden`、使用伪元素（`::after { content: ""; display: block; clear: both; }`）。
  - 定位（position 属性）：
    - `static`（默认）：元素在正常文档流中，不接受`top`/`left`等定位属性。
    - `relative`（相对定位）：相对于元素自身在文档流中的原始位置偏移，不脱离文档流。
    - `absolute`（绝对定位）：相对于最近的已定位（非 static）祖先元素偏移，脱离文档流。
    - `fixed`（固定定位）：相对于浏览器窗口定位，脱离文档流，滚动页面时位置不变（如固定导航栏）。

- 进阶内容

  ：

  - Flex 布局：弹性盒模型，通过给父元素设置`display: flex`，控制子元素的排列方向、对齐方式、占比等，适合一维布局（行或列）。
  - Grid 布局：网格布局，通过`display: grid`将父元素划分为二维网格，适合复杂的二维布局。
  - CSS 动画：使用`@keyframes`定义动画关键帧，配合`animation`属性（如`animation: 动画名 时长 运动曲线 延迟 播放次数 是否反向`）实现动画效果。
  - 响应式设计：通过媒体查询（`@media (max-width: 768px) { ... }`）根据不同屏幕尺寸设置不同样式，适配移动端、平板、PC 等设备。

### 3. JavaScript（JS）

- **核心作用**：赋予页面交互能力，实现动态效果、数据处理等功能。

- 基础语法

  ：

  - 变量：`var`（ES5，函数级作用域，可重复声明）、`let`（ES6，块级作用域，不可重复声明）、`const`（ES6，块级作用域，声明常量，不可修改）。
  - 数据类型：
    - 基本类型：字符串（`string`）、数字（`number`）、布尔（`boolean`）、`null`（空值）、`undefined`（未定义）、`Symbol`（唯一标识）。
    - 引用类型：数组（`array`）、对象（`object`）、函数（`function`）。
  - 运算符：算术运算符（`+`、`-`、`*`、`/`）、比较运算符（`>`、`<`、`===`全等）、逻辑运算符（`&&`与、`||`或、`!`非）等。
  - 条件语句：`if-else`、`switch-case`。
  - 循环语句：`for`、`while`、`do-while`。

- 核心概念

  ：

  - 函数：声明式函数（`function 函数名() {}`）、箭头函数（`(参数) => {}`，简化语法，无`this`绑定）。
  - 作用域与闭包：
    - 作用域：变量可访问的范围（全局作用域、函数作用域、块级作用域）。
    - 闭包：函数嵌套时，内部函数可访问外部函数的变量，且外部函数执行后变量不被销毁（常用于封装私有变量）。
  - 原型与原型链：JS 通过原型实现继承，每个对象都有`__proto__`属性指向原型对象，原型对象的`__proto__`形成链条，直到`null`。
  - 异步编程：解决 JS 单线程阻塞问题，包括回调函数（嵌套易产生 “回调地狱”）、Promise（链式调用优化异步）、`async/await`（同步语法写异步，基于 Promise）。

- DOM 操作

  ：

  - 获取元素：`document.getElementById("id")`（通过 ID 获取）、`document.querySelector("选择器")`（通过 CSS 选择器获取第一个匹配元素）、`document.querySelectorAll("选择器")`（获取所有匹配元素）。
  - 修改元素：`element.innerHTML`（修改内容，可解析 HTML）、`element.innerText`（修改文本，不解析 HTML）、`element.style.样式名`（修改行内样式）。
  - 事件绑定：`element.addEventListener("事件类型", 回调函数)`（如`click`点击事件、`mouseover`鼠标悬停事件）。

## 二、前后端数据交互

### 1. 数据格式小结

#### （1）客户端发送数据

- 编码方式

  ：

  - `application/x-www-form-urlencoded`：URL 编码格式（`key=value&key2=value2`），适合简单键值对数据。
  - `application/json`：UTF-8 编码的 JSON 格式（`{"key":"value"}`），适合发送结构化数据（对象、数组）。
  - `multipart/form-data`：多部分编码，每部分数据可单独指定格式，适用于文件 + 表单混合上传（文件上传必须用此格式）。

- 发送规则

  ：

  - 表单（`<form>`）仅支持：`application/x-www-form-urlencoded`、`multipart/form-data`。
  - JavaScript（如`fetch`、`axios`）可支持任意格式发送数据。

#### （2）服务端接收数据（以 Spring MVC/Spring Boot 为例）

- `application/x-www-form-urlencoded` 和 `multipart/form-data`：

  - 处理方式相同，无需额外注解。

  - 接收方式：使用 Java Bean，属性名与请求参数名对应，Spring 自动绑定。

    java

    ```java
    public class User {
        private String name;
        private Integer age;
        // getter / setter
    }
    
    @PostMapping("/save")
    public String save(User user) {
        return user.getName();
    }
    ```

- `application/json`：

  - 必须使用

    ```
    @RequestBody + Java Bean
    ```

    接收。

    java

    ```java
    @PostMapping("/save")
    public String save(@RequestBody User user) {
        return user.getName();
    }
    ```

- **常见问题（⚠️）**：

  - 忘记加`@RequestBody`：JSON 数据无法绑定，参数为`null`。
  - JSON 属性名必须与 Java Bean 字段名一致（如需映射不同名称，可用`@JsonProperty`注解）。
  - 控制器方法中`@RequestBody`只能有一个（但可与普通参数共存）。

### 2. Session 原理

#### （1）背景

- **HTTP 无状态**：每次请求都是独立的，请求之间不会自动保存数据（例：第一次请求传入的用户信息，第二次请求无法直接复用）。
- **会话需求**：通过技术让同一个客户端与服务端之间的多次请求共享数据（如保持用户登录状态）。

#### （2）Session 技术

- **作用**：服务端暂存用户数据，使数据在多次请求中保持。
- **常见用途**：用户登录状态、购物车数据、临时表单信息等。

#### （3）工作流程

1. 首次请求
   - 客户端发起请求，服务端创建`Session`对象，并生成唯一`Session ID`（如`JSESSIONID`）。
   - 服务端通过响应头`Set-Cookie`将`Session ID`发送给客户端。
   - 客户端将`Session ID`保存在浏览器`Cookie`中。
2. 后续请求
   - 客户端请求时，在`Cookie`中附带`JSESSIONID`。
   - 服务端通过`Session ID`找到对应的会话数据，实现数据共享。

#### （4）示例

- 第一次请求（创建 Session）：

  http

  ```http
  GET /s1?name=zhang HTTP/1.1
  Host: localhost
  ```

  服务端响应：

  http

  ```http
  Set-Cookie: JSESSIONID=BF219FEFB6FF6960DA2537CDDED6C393
  ```

- 第二次请求（使用 Session）：

  http

  ```http
  GET /s2 HTTP/1.1
  Host: localhost
  Cookie: JSESSIONID=BF219FEFB6FF6960DA2537CDDED6C393
  ```

  服务端根据JSESSIONID找到上一次保存的数据。

#### （5）补充细节

- **Session 存储位置**：默认存储在服务器内存，也可配置到数据库、Redis 等（适合分布式系统）。
- **生命周期**：默认 30 分钟（Tomcat 默认），可在`web.xml`或 Spring Boot 配置文件中修改。
- Cookie 依赖
  - 若客户端禁用 Cookie，可通过**URL 重写**传递`JSESSIONID`（例：`http://localhost/s2;jsessionid=BF219FEFB6FF6960DA2537CDDED6C393`）。
- 安全注意事项
  - 防止 Session 固定攻击（Session Fixation）：用户登录时重新生成`Session ID`。
  - 防止 Session 劫持：使用 HTTPS 加密传输，避免中间人攻击。





# 前端学习笔记（第二天）：认证流程对比（Session vs JWT）

## 一、Session 认证流程

1. 用户提交账号和密码到服务器。
2. 服务器验证账号密码的有效性。
3. 验证成功后，在服务器内存或数据库中**创建 Session**（存储用户信息，如用户名、权限等）。
4. 服务器生成唯一的 **Session ID**，并通过响应头 `Set-Cookie` 将其封装到 Cookie 中，返回给客户端。
5. 客户端后续每次请求时，都会自动带上包含 Session ID 的 Cookie。
6. 服务器接收请求后，根据 Cookie 中的 Session ID 查找对应的 Session 信息，验证通过后处理请求。

## 二、JWT 认证流程

1. 用户提交账号和密码到服务器。
2. 服务器验证账号密码的有效性。
3. 验证成功后，**生成包含用户信息的 JWT（JSON Web Token）**（包含头部、载荷、签名三部分，签名确保 token 不被篡改）。
4. 服务器将 JWT 直接返回给客户端，客户端通常将其存储在 `localStorage`、`sessionStorage` 或 Cookie 中。
5. 客户端后续每次请求时，需在请求头 `Header` 中附加 `Authorization: Bearer <token>`（其中 `<token>` 为 JWT 字符串）。
6. 服务器接收请求后，**验证 JWT 的签名有效性**（无需查询数据库），解析出载荷中的用户信息，验证通过后处理请求。

## 三、Session 与 JWT 认证流程对比（合并流程图）

plaintext

```plaintext
        用户登录
           |
       账号+密码
           |
    +------v------+
    | 服务器验证  |
    +------+------+   
           |
    +------+------+--------------------------+
    | Session 方式                          | JWT 方式
    |----------------------------------------|--------------------------------
    | 1. 创建 Session 并保存到服务端         | 1. 生成 JWT（包含用户信息+签名）
    | 2. 返回 Session ID 并放到 Cookie 中    | 2. 直接返回 JWT 给客户端（客户端自行存储）
    | 3. 客户端后续请求自动携带 Cookie       | 3. 客户端请求时在 Header 中附加 JWT
    |    （包含 Session ID）                 |    （格式：Authorization: Bearer <token>）
    | 4. 服务器通过 Session ID 查库/内存     | 4. 服务器验证 JWT 签名有效性，直接解析
    |    获取用户信息并验证                  |    载荷中的用户信息（无需查库）
    +----------------------------------------+--------------------------------
```

## 四、核心差异补充

| 对比维度 | Session 方式                                  | JWT 方式                            |
| -------- | --------------------------------------------- | ----------------------------------- |
| 存储位置 | 用户信息存储在**服务端**                      | 用户信息包含在**客户端的 token 中** |
| 状态依赖 | 服务端需维护会话状态（有状态）                | 服务端无需维护状态（无状态）        |
| 扩展性   | 分布式系统中需共享 Session（如用 Redis 同步） | 天然支持分布式（无需共享状态）      |
| 安全性   | 依赖 Cookie，需防范 CSRF 攻击                 | 存储在客户端，需防范 XSS 攻击       |
| 过期处理 | 服务端直接删除 Session 即可                   | 需客户端主动删除或等待过期          |

通过对比可见，Session 更适合单体应用，JWT 更适合分布式系统或前后端分离架构，但需根据实际场景权衡安全性和便利性。







# 前端学习笔记（第三天）：JavaScript 数据类型与函数

## 一、变量声明方式（var、let、const）

在 JavaScript 中，变量声明主要有三种方式，核心差异体现在作用域、重复声明和变量修改限制上：

- var
  - 作用域：函数级作用域（在函数外声明为全局变量，函数内声明仅在函数内有效）。
  - 特点：允许重复声明，变量可被重新赋值，存在变量提升（声明会被提升到作用域顶部，赋值保留在原位）。
- let
  - 作用域：块级作用域（用`{}`包裹的区域，如`if`、`for`块内）。
  - 特点：不允许重复声明，变量可被重新赋值，不存在变量提升（声明前使用会报错）。
- const
  - 作用域：块级作用域。
  - 特点：不允许重复声明，**声明时必须初始化**，且变量指向的内存地址不可修改（基本类型值不可变，对象 / 数组可修改内部属性）。

## 二、基本数据类型

JavaScript 基本数据类型包括 `undefined`、`null`、`string`、`number`、`bigint`、`boolean`、`symbol`，具体特性如下：

### 1. undefined 和 null

- 二者统称Nullish

  ，均表示 “空” 或 “无”，但场景不同：

  - ```
    undefined
    ```

    - 执行表达式 / 函数无返回结果时默认返回。
    - 访问数组不存在的元素、对象不存在的属性时返回。
    - 声明变量未初始化时的默认值（如`let a;`则`a`为`undefined`）。

  - `null`：通常由开发者主动赋值，表示 “刻意为空”（如`let b = null;`）。

### 2. string（字符串）

- 表示文本数据，可用单引号（`'`）、双引号（`"`）或反引号（```）包裹。

- 模板字符串（Template strings）

  - 用反引号包裹，支持换行和变量嵌入（语法：`${变量名}`），简化字符串拼接。

  - 示例：拼接请求参数

    javascript

    ```javascript
    let name = "zhang";
    let age = 18;
    // 传统拼接：let uri = "/test?name=" + name + "&age=" + age;
    let uri = `/test?name=${name}&age=${age}`; // 结果："/test?name=zhang&age=18"
    ```

### 3. number（数字）

- 表示双精度浮点小数（整数、小数均包含在内），存在以下特性：

  - 除法运算可能产生精度问题（如`2.0 - 1.1 = 0.8999999999999999`）。

  - 允许除以 0，结果为`Infinity`（正无穷）或`-Infinity`（负无穷）。

  - 字符串转数字：使用parseInt()，转换失败返回

    NaN（Not a Number）。

    javascript

    ```javascript
    parseInt("10"); // 10（成功）
    parseInt("10.5"); // 10（忽略小数部分）
    parseInt("abc"); // NaN（失败）
    ```

### 4. bigint（大整数）

- 用于表示超出`number`范围的整数，语法：数字后加`n`（如`10n`、`123n`）。
- 特性：
  - 支持整数运算（如`10n / 3n = 3n`，自动取整）。
  - 不允许除以 0（会报错）。
  - 不能与`number`直接运算（需先转换类型）。

### 5. boolean（布尔值）

- 仅包含`true`（真）和`false`（假）两个值，常用于条件判断。

### 6. Truthy / Falsy（真值 / 假值）

JavaScript 中，非布尔值在条件判断（如`if`语句）中会被隐式转换为布尔值，分类如下：

- **Falsy（假值）**：转换后为`false`的值
  `false`、`null`、`undefined`、`0`、`0n`、`NaN`、`""`（空字符串）。

- **Truthy（真值）**：转换后为`true`的值（除假值外均为真值）
  特殊示例：`"false"`（非空字符串）、`"0"`（非空字符串）、`[]`（空数组）、`{}`（空对象）。

  javascript

  ```javascript
  let b = 1;
  if (b) { // 1 是真值，条件为 true
    console.log("进入了"); // 会执行
  }
  ```

### 7. symbol（符号）

- 表示唯一且不可变的值，用于对象属性的唯一标识（避免属性名冲突）。
- 语法：`const s = Symbol("描述符");`（描述符仅用于调试，不影响唯一性）。
- 特性：即使描述符相同，两个`symbol`也不相等（`Symbol("a") !== Symbol("a")`）。

## 三、对象类型：Function（函数）

函数是 JavaScript 中的一等公民，可作为变量、参数或返回值，定义方式和特性如下：

### 1. 函数定义（声明式）

javascript

```javascript
function 函数名(参数) {
  // 函数体
  return 结果; // 可选，无 return 则默认返回 undefined
}

// 示例：加法函数
function add(a, b) {
  return a + b;
}
```

### 2. 函数调用特点

- 参数无限制

  ：对参数类型和个数没有严格检查

  javascript

  ```javascript
  add('a', 'b'); // 返回 "ab"（字符串拼接）
  add(4, 5, 6); // 返回 9（忽略多余参数）
  add(1); // 返回 NaN（b 为 undefined，运算结果为 NaN）
  ```

### 3. 默认参数

函数参数可设置默认值，调用时未传参则使用默认值（类似 Java 的`@RequestParam(defaultValue)`）：

javascript

```javascript
// 分页函数：默认页码 1，每页条数 10
function pagination(page = 1, size = 10) {
  console.log(page, size);
}

pagination(); // 输出：1 10（使用默认参数）
pagination(2); // 输出：2 10（仅传第一个参数）
```

### 4. 匿名函数（无函数名）

- 语法：`(function(参数) { /* 函数体 */ })`

- 常见场景：

  1. 立即执行

     （定义后直接调用）

     javascript

     ```javascript
     (function(a, b) {
       console.log(a + b);
     })(1, 2); // 输出：3
     ```

  2. 作为对象方法

     （如事件绑定）

     javascript

     ```javascript
     // 给 id 为 "p1" 的元素绑定点击事件
     document.getElementById("p1").onclick = (function() {
       console.log("点击了");
     });
     ```

### 5. 箭头函数（简化语法）

- 语法：`(参数) => { /* 函数体 */ return 结果; }`

- 简化规则：

  - 若只有一个参数，可省略括号（`参数 => { ... }`）。
  - 若函数体只有一行代码，可省略大括号和`return`（自动返回该行结果）。

- 示例：

  javascript

  ```javascript
  // 完整写法
  const add = (a, b) => { return a + b; };
  
  // 简化写法（单参数+单行代码）
  const double = num => num * 2;
  
  // 事件绑定示例
  document.getElementById("p1").onclick = () => console.log("鼠标单击了...箭头函数");
  ```

  

  

  ![img](data:image/png;base64,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)

## 总结

第三天主要学习了 JavaScript 的变量声明方式、7 种基本数据类型（重点区分`undefined`与`null`、`number`与`bigint`，以及 Truthy/Falsy 规则），并深入理解了函数的定义、调用特点、默认参数、匿名函数和箭头函数。这些是 JS 核心语法的基础，对后续处理数据和交互逻辑至关重要。





# 前端学习笔记：JavaScript 作用域与闭包

## 一、函数作用域

### 1. 基本概念

- 函数内部声明的变量，仅在函数内部可访问
- 函数是 JavaScript 中最基本的作用域单元

### 2. 函数嵌套

函数内部可以嵌套另一个函数，嵌套的内部函数可以访问外部函数的变量

javascript

```javascript
function a() {
  // 函数a的作用域
  function b() {
    // 函数b的作用域，可以访问a中的变量
  }
}
```

### 3. 作用域访问规则示例

javascript

```javascript
var x = 10; // 全局作用域

function a() {
  var y = 20; // a函数作用域
  
  function b() {
    // b函数作用域可以访问：
    // - 自身作用域变量
    // - 外部函数a的变量(y)
    // - 全局变量(x)
    console.log(x, y); // 输出10 20
  }
  
  b(); // 在a内部调用b
}

a();
```

## 二、闭包

### 1. 概念理解

- 闭包指函数能够访问定义时所在作用域中的变量，即使函数在外部执行
- 核心：函数定义时的作用域已确定，与执行位置无关

### 2. 典型示例

javascript

```javascript
var x = 10; // 全局变量

function a() {
  var y = 20; // a函数的局部变量
  
  function b() {
    // b函数定义时可以访问x和y
    console.log(x, y); 
  }
  
  return b; // 返回内部函数b
}

// 执行a()得到函数b，在全局作用域执行b
a()(); // 输出10 20（仍能访问a中的y）
```

### 3. 闭包的本质

函数保留了对定义时所在作用域的引用，使得即使外部函数执行完毕，内部函数仍能访问其变量

## 三、let、var 与作用域的关系

### 1. let 与作用域

- let 声明的变量具有块级作用域
- 普通 `{}` 会成为 let 变量的作用域边界
- 最外层的 let 变量属于 script 作用域

javascript

```javascript
let x = 10; // script作用域

if (true) {
  let y = 20; // if块级作用域
  function b() {
    console.log(x, y); // 可访问x和y
  }
  b(); // 输出10 20
}

// console.log(y); // 报错：y未定义（超出作用域）
```

### 2. var 与作用域

- var 声明的变量不具有块级作用域，仅受函数作用域限制
- 普通 `{}` 不会成为 var 变量的作用域边界

javascript

```javascript
var x = 10; // 全局作用域

if (true) {
  var y = 20; // 仍属于全局作用域（因为用var声明）
  function b() {
    console.log(x, y); 
  }
  b(); // 输出10 20
}

console.log(y); // 输出20（var不受if块限制）
```

### 3. var 的重名问题

- var 允许重复声明，会被视为同一作用域中的同一个变量
- 解决办法：使用 let 或函数作用域隔离

#### 问题示例：

javascript

```javascript
var e = 10;
if (true) {
  var e = 20; // 与外部e是同一个变量
  console.log(e); // 输出20
}
console.log(e); // 输出20（外部e被修改）
```

#### 解决方法 1：使用 let

javascript

```javascript
let e = 10;
if (true) {
  let e = 20; // 独立的块级变量
  console.log(e); // 输出20
}
console.log(e); // 输出10（外部e不受影响）
```

#### 解决方法 2：使用函数作用域

javascript

```javascript
var e = 10;
if (true) {
  function b() {
    var e = 20; // 函数内的局部变量
    console.log(e); // 输出20
  }
  b();
}
console.log(e); // 输出10（外部e不受影响）
```



![img](data:image/png;base64,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)

## 总结

1. 函数作用域是 JavaScript 中最基本的作用域单元，支持嵌套
2. 闭包的核心是函数能记住定义时的作用域，无论在哪里执行
3. let 支持块级作用域，普通 `{}` 即可作为边界
4. var 不支持块级作用域，仅受函数作用域限制，且允许重复声明
5. 开发中推荐使用 let 替代 var，可避免许多作用域相关的问题



# 第五天学习笔记 - JavaScript 数组 (Array)

## 1. 数组的基本语法

### 创建数组
```js
let arr = [1, 2, 3];
获取数组元素
js
复制
编辑
console.log(arr[0]); // 输出 1
修改数组元素
js
复制
编辑
arr[0] = 5;  
console.log(arr); // [5, 2, 3]
遍历数组元素
length 是数组的属性，表示数组长度。

js
复制
编辑
for (let i = 0; i < arr.length; i++) {
  console.log(arr[i]);
}
2. 常用 API
push()
向数组 尾部 (右侧) 添加元素。

js
复制
编辑
let arr = [1, 2, 3];
arr.push(4);
console.log(arr); // [1, 2, 3, 4]
shift()
从数组 头部 (左侧) 移除元素。

js
复制
编辑
arr.shift();
console.log(arr); // [2, 3, 4]
splice()
删除或替换数组中的元素。

js
复制
编辑
// 删除索引 1 位置的 1 个元素
arr.splice(1, 1);
console.log(arr); // [2, 4]
3. 数组转字符串
join()
将数组元素拼接为字符串。

js
复制
编辑
let arr = ['a', 'b', 'c'];
console.log(arr.join('-')); // "a-b-c"
4. 高阶方法
map()
对数组中的每个元素执行函数，返回 新数组。

js
复制
编辑
let arr = [1, 2, 3];
let result = arr.map(x => x * 2);
console.log(result); // [2, 4, 6]
filter()
筛选符合条件的元素，返回 新数组。

js
复制
编辑
let arr = [1, 2, 3, 4];
let result = arr.filter(x => x % 2 === 0);
console.log(result); // [2, 4]
forEach()
遍历数组，不返回新数组（常用于执行副作用操作）。

js
复制
编辑
let arr = [1, 2, 3];
arr.forEach(x => console.log(x));
// 输出：1 2 3
✅ 小结：

push / shift / splice 用于 增删元素。

join 将数组转为字符串。

map / filter / forEach 属于 高阶方法，常用于函数式编程。