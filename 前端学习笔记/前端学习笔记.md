用匿名函数

```js
let stu = {
    name: "小金",
    friends: ["小黑", "小白", "小青"],

	play() {
   	 	this.friends.forEach(function(e){
     		console.log(this.name + "与" + e + "play");
    	});
	}

};
```

输出结果：

```js
stu.play();
VM2222:7 与小黑play
VM2222:7 与小白play
VM2222:7 与小青play
```

用箭头函数

```js
let stu = {
    name: "小金",
    friends: ["小黑", "小白", "小青"],

	play() {
   	 	this.friends.forEach(e => {
     		console.log(this.name + "与" + e + "play");
    	});
	}
};
```



- this.name所在的函数时箭头函数，因此this是取的外层play函数的对象。而play是属于stu的方法，因此this代表stu对象

输出结果为：

```javascript
stu.play();
VM2125:7 小金与小黑play
VM2125:7 小金与小白play
VM2125:7 小金与小青play
```

不用箭头函数的做法

```js
let stu = {
    name: "小金",
    friends: ["小黑", "小白", "小青"],

	play() {
		let param=this;
	 	this.friends.forEach(function(e){
	 		console.log(param.name + "与" + e + "play");
		});
	}

};
```



**特色：原型继承**

```js
let father= {
    f1:"父属性",
    m1: function(){
        console.log("父方法");
    }
}

let son =Object.create(father);

console.log(son.f1);  //打印父属性
son.m1();    //打印父方法
```

- 
  father是父对象，son去调用.m1或.f1时，自身对象没有，就到父对象找。

- son 自己可以添加自己的属性和方法

- son 里有特殊属性_proto_代表它的父对象，js 术语: son 的原型对象

- 不同浏览器对打印 son的_proto_ 属性时显示不同

  - ​		Edge 打印 console,dir(son)显示[[Prototype]]

  - ​        Firefox打印console,dir(son)显示<prototype>

**特色：基于函数的原型继承**

出于方便的原因，js 又提供了一种基于函数的原型继承
	函数职责
		1.负责创建子对象，给予对象提供属性、方法，功能上相当于构造方法										    		2.函数有个特殊的属性 prototype，它就是函数创建的子对象的父对象

​         **注意!**    名字有差异，这个属性的作用就是为新对象提供原型

```js
function cons(f2){
    //创建子对象（this）
    this.f2=f2;
    this.m1= function(){
        console.log("子方法");
    }
}
//cons.prototype  就是父对象
cons.prototype.f1="父属性";
cons.prototype.m1=function(){
        console.log("父方法");
    }
```

使用**new**关键字，创建子对象

```js
let son=new cons("子属性")
```

子对象_proto_  就是函数的prototype属性



**JSON**

java与js的json：

1.本质不同

- json 对象本质上是个字符串，它的职责是作为客户端和服务器之间传递数据的一种格式，它的属性只是样子货
- js 对象是切切实实的对象，可以有属性方法

2.语法细节不同

- json 中只能有 null、truelfalse、数字、字符串(只有双引号)、对象、数组
- json 中不能有除以上的其它js 对象的特性，如方法等
- json 中的属性必须用双引号引起来

json字符串与js对象转换

```js
JSON.parse(json字符串)  //返回js对象
JSON.stringify(js对象)  //返回json字符串
```



**动态类型**

js属于动态类型语言，值有类型，但是变量没有类型，赋值给变量时，没要求。

动态类型看起来比较灵活，但变量没有类型，后期维护比较困难



## 2、运算符与表达式 

### 1） ===

严格相等运算符，用作逻辑判等。

```js
1==1     //true
1=='1'   //true,回会先将右侧的字符串转为数字，在做比较
1==='1'  //false  类型不等，直接返回false
```

typeof查看某个值的类型

**2）||**

值1 || 值2

如果值1是Truthy,返回值1；如果是falsy,返回值2

**3）？？与？.**

```js
(n = n ?? '男')   <=>   (n === undefined || n === null ) {n='男'}
```

当某个属性是nullish时，短路返回undefined

```js
function test(stu){
    console.log(stu.address?.city)
}
```

**4)...**

展开运算符

作用1：打散数组传递多个参数

```js
let arr=[1,2,3];

function test(a,b,c){
    console.log(a,b,c);
}
```

结果

```js
test(...arr)
1 2 3
```

作用2：复制数组或对象

```js
let arr1=[1,2,3];
let arr2=[...arr1]
```

结果：

```js
arr1.push(5)
4
arr1
(4) [1, 2, 3, 5]
arr2
(3) [1, 2, 3]
```

对象

```js
let obj1={name:"张三"，age:16};

let obj2={...obj1};
```

**注意：展示运算符复制属于浅拷贝**

```js
let o1={name:"张三",address:{city:"北京"}};

let o2={...o1};
```

结果：

![image-20250819093513656](C:\Users\DELL\Documents\MarkDown\前端学习笔记\image\image-20250819093513656.png)

作用3：合并数组或对象

合并数组：

```js
let arr1=[1,2,3];
let arr2=[4,5];

let b=[...arr1,...arr2]
```

合并对象：

```js
let o1={name:"zhangshan"};
let o2={age:"18"};
let o3={name:"zhangshan2222"};

let user={...o1,...o2};

let user={...o1,...o3};
name会覆盖前面同名属性
```

**5)[]{}**

解构赋值

**[]**

用在申明变量时

```js
let arr =[1,2,3]

let [a,b,c]=arr;  //结果a=1,b=2,c=3
```

用在申明参数时

```js
let arr=[1,2,3];

function test([a,b,c]){
    console.log(a,b,c);
}

test(arr);
```

**{}**

用在声明变量时

```js
let obj={name:"张三",age:19};

let {name,age}=obj;
```

![image-20250819100259171](C:\Users\DELL\Documents\MarkDown\前端学习笔记\image\image-20250819100259171.png)

用在声明参数时：

```js
let obj={name:"张三",age:19};


function test({name,age}){
    console.log(name,age);
}

test(obj);
```

![image-20250819100451371](C:\Users\DELL\Documents\MarkDown\前端学习笔记\image\image-20250819100451371.png)

## 3.控制语句

### 1）for in

主要用来遍历对象

```js
let father ={name:"张三",age:18,study:function(){}};

for(const n in father){
    console.log(n);
}
```

其中const  n 代表遍历出来的属性名

- 
  注意1:方法名也能被遍历出来(它其实也算一种特殊属性)
- 注意2:遍历子对象时，父对象的属性会跟着遍历出来

```js
let son=Object.create(father);

son.set="nan";

for(const n  in  son){
    console.log(n);
}
```

![image-20250819102835641](C:\Users\DELL\Documents\MarkDown\前端学习笔记\image\image-20250819102835641.png)

- 注意3:在 for in 内获取属性值，要使用[]语法,而不能用.语法

```js
for(const n in  son ){
    console.log(n,son[n]);
}
```

![image-20250819103059165](C:\Users\DELL\Documents\MarkDown\前端学习笔记\image\image-20250819103059165.png)

### 2)for of

主要用来遍历数组，也可以是其它可选代对象，如Map，set等

```js
let a1=[1,2,3];

for(const i of a1){
    console.log(i);
}


let a2=[{name:'张三',age:18},
       {name:"lisi",age:20}]

for (const obj of a2){
    console.log(obj.name,obj.age);
}

for (const {name,age} of a2){
    console.log(name,age);
}




```

![image-20250819111715503](C:\Users\DELL\Documents\MarkDown\前端学习笔记\image\image-20250819111715503.png)

### 3)try catch



## 4.API

#### 环境准备

### 1)安装 nvm

nvm 即(node version manager)，好处是方便切换 node.js 版本

安装注意事项

1. 1.要卸载掉现有的 nodejs
2. 2.提示选择 nvm 和 nodejs 目录时，一定要避免目录中出现空格
3. 3.选用【以管理员身份运行】cmd 程序来执行nvm 命令
4. 4.首次运行前设置好国内镜像地址

```shell
nvm node_mirror http://npm.taobao.org/mirrors/node/
nvm npm_mirror https://npm.taobao.org/mirrors/npm/

nvm node_mirror https://npmmirror.com/mirrors/node/
nvm npm_mirror https://npmmirror.com/mirrors/npm/
```


首先查看有哪些可用版本

```shell
nvm  list  available

nvm install 18.20.4
nvm use 18.20.4
```

### 2)检查 npm

npm 是js的包管理器，就类似于java 界的 maven，要确保它使用的是国内镜像工检查镜像
```shell
npm get registry
```

如果返回的不是https://registry.npmmirror.com/，需要做如下设置

````shell
npm config set registry https://registry.npmmirror.com/
````

### 3)搭建简单服务

```shell
npm init -y

npm install express --save-dev
```

修改 package.json 文件

```json
{
  "name": "client",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
    //打包相关工具
  "type": "module",
  "description": "",
  "devDependencies": {
    "express": "^5.1.0"
  }
}
```

添加main.js

```js
import express from 'express'
const app=express()
app.use(express.static('./'))
app.listen(7070)
```

添加index.html

```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>示例 API 客户端</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
    <h1>欢迎使用示例 API 客户端</h1>
    <div id="app">
        <!-- 内容区域 -->
    </div>
</body>
</html>
```

```shell
node main.js
```



访问http://localhost:7070/index.html

![image-20250819162841817](C:\Users\DELL\Documents\MarkDown\前端学习笔记\image\image-20250819162841817.png)

### **1️⃣ 页面元素查询方法**

| 方法                                  | 说明                               | 示例                                       |
| ------------------------------------- | ---------------------------------- | ------------------------------------------ |
| `document.querySelector(selector)`    | 返回**第一个匹配**的元素           | `document.querySelector(".student-list")`  |
| `document.querySelectorAll(selector)` | 返回**所有匹配**的元素（NodeList） | `document.querySelectorAll(".student-id")` |
| `document.getElementById(id)`         | 根据id获取元素                     | `document.getElementById("id")`            |

> ⚠️ 注意：`querySelectorAll` 返回的是类数组（NodeList），可以用 `forEach` 遍历。

------

### **2️⃣ 内容读取与修改**

| 属性          | 作用                                            | 示例                                                         |
| ------------- | ----------------------------------------------- | ------------------------------------------------------------ |
| `innerHTML`   | 获取或设置元素的 **HTML内容**，会解析标签       | `<div id="test"><span>123</span></div>`   `document.getElementById("test").innerHTML` → `"<span>123</span>"` |
| `textContent` | 获取或设置元素的 **文本内容**，不会解析HTML标签 | `<div id="test"><span>123</span></div>`   `document.getElementById("test").textContent` → `"123"` |

> 🔹 两者都可以赋空字符串 `` 来清空内容。

根据js，动态设值表格数值

```js
   <template id="student-template">
        <div class="student-row">
            <span class="student-id"></span> 
            <span class="student-name"></span>
            <span class="student-sex"></span>
            <span class="student-age"></span>
        </div>
    </template>   

<script>
    let students = [
        { id: 1, name:"张三",sex:"男", age: 18 },
        { id: 2, name:"李四",sex:"女", age: 19 },
        { id: 3, name:"王五",sex:"男", age: 20 },
        { id: 4, name:"赵强",sex:"男", age: 21 },
        { id: 5, name:"钱六",sex:"女", age: 22 }                                 
    ];      
    
    students.forEach(stu => {
        let template = document.getElementById('student-template').content.cloneNode(true);
        template.querySelector('.student-id').textContent = stu.id;
        template.querySelector('.student-name').textContent = stu.name;
        template.querySelector('.student-sex').textContent = stu.sex
        template.querySelector('.student-age').textContent = stu.age;
        document.querySelector('.student-list').appendChild(template);
    });

    students.forEach(stu1 => {
        let item=document.createElement('div');
        item.className = 'student-row';
        item.innerHTML = `
            <span class="student-id">${stu1.id}</span>
            <span class="student-name">${stu1.name}</span>
            <span class="student-sex">${stu1.sex}</span>
            <span class="student-age">${stu1.age}</span>`;
        document.querySelector('.student-list').appendChild(item);    
    });



        //  document.querySelector('.student-list').innerHTML += `
        //     <div class="student-row">
        //         <span class="student-id">2</span>
        //         <span class="student-name">李四</span>
        //         <span class="student-sex">女</span>
        //         <span class="student-age">19</span> 
        //         </div> <div class="student-row"><span class="student-id">3</span>
        //         <span class="student-name">王五</span> <span class="student-sex">男</span>
        //         <span class="student-age">20</span> `;
        //         document.querySelector('.student-list').textContent
        //  document.querySelector('.student-row').textContent =` `;
   </script>
```

# 🌐 Fetch API

`Fetch API` 用于在浏览器中请求远程数据（HTTP 请求）。
 基本格式：

```
fetch(url, options)
```

- **url**：请求地址

- **options**：配置对象（如 method、headers、body 等）

  ```
  {
    method: "POST", // 请求方式 GET / POST / PUT / DELETE...
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ key: "value" })
  }
  ```

------

## 1️⃣ 异步方式（Promise 链式写法）

```
fetch(url, options)
  .then(response => response.json()) // 把响应结果解析为 JSON
  .then(data => {
    console.log("请求结果:", data);
  })
  .catch(error => {
    console.error("请求失败:", error);
  });
```

📌 特点：

- 使用 **`.then()`** 来处理返回结果
- **后续代码不会等待**，会继续执行

示例：

```html
  <script>
//使用fetch 异步请求处理
        fetch(`data.json`)
        .then(res =>res.json())
        .then(students =>{
            students.forEach(stu => {
                let template = document.getElementById('student-template').content.cloneNode(true);
                template.querySelector('.student-id').textContent = stu.id;
                template.querySelector('.student-name').textContent = stu.name;
                template.querySelector('.student-sex').textContent = stu.sex
                template.querySelector('.student-age').textContent = stu.age;
                document.querySelector('.student-list').appendChild(template);
            });
        })
</script>
```



------

## 2️⃣ 同步方式（`async/await` 写法）

```
async function getData() {
  try {
    const response = await fetch(url, options); // 等待请求完成
    const data = await response.json();         // 等待解析 JSON
    console.log("请求结果:", data);
  } catch (error) {
    console.error("请求失败:", error);
  }
}

getData();
```

📌 特点：

- 使用 **`await`** 等待结果，写法更像同步代码
- 必须在 `async function` 内部使用 
-  await 关键字必须在一个标记了 async 的 function 内来使用
- **后续代码会等待请求完成后再执行**

示例：

```html
  <script>

    async function findStudents(){
        const resp= await fetch(`data.json`)
        const students=await resp.json();
        students.forEach(stu => {
            let template = document.getElementById('student-template').content.cloneNode(true);
            template.querySelector('.student-id').textContent = stu.id;
            template.querySelector('.student-name').textContent = stu.name;
            template.querySelector('.student-sex').textContent = stu.sex
            template.querySelector('.student-age').textContent = stu.age;
            document.querySelector('.student-list').appendChild(template);
        });
    }
    findStudents();
</script>
```





## 1️⃣ 同源请求

### 定义

- **同源**指：协议（protocol）、域名（host）、端口（port）都相同。

### 你的例子

```
浏览器页面来自前端服务器
fetch 请求前端 JSON（同一服务器）
```

- 协议、域名、端口一致 ✅

- **属于同源请求**，浏览器不会拦截，可以直接返回。

  ![微信图片_20250824223713_8_2](C:\Users\wyy65\Documents\clinet_study\前端学习笔记\image\微信图片_20250824223713_8_2.jpg)

------

## 2️⃣ 跨域请求

### 定义

- **跨域**指：协议、域名或端口有任意一项不同。

### 你的例子

```
浏览器页面来自前端服务器
fetch 请求后端接口（后端服务器域名或端口不同）
```

- 协议、域名或端口不一样 ❌

- **属于跨域请求**，浏览器默认会拦截，需要后端允许跨域（CORS）或通过代理解决。

  ![微信图片_20250824223713_8_2](C:\Users\wyy65\Documents\clinet_study\前端学习笔记\image\微信图片_20250824223713_8_2.jpg)

------

## 3️⃣ 跨域解决方式

1. **后端允许 CORS**（最常见）

   - 后端在响应头加：在方法上加@CrossOrigin("*")也可以解决

   ```
   Access-Control-Allow-Origin: *
   Access-Control-Allow-Methods: GET, POST, PUT, DELETE
   Access-Control-Allow-Headers: Content-Type
   ```

   - 可以限制特定域名代替 `*`。

     <img src="C:\Users\wyy65\Documents\clinet_study\前端学习笔记\image\2222.jpg" alt="2222" />

     <img src="C:\Users\wyy65\Documents\clinet_study\前端学习笔记\image\33332.jpg" alt="33332" />

2. **前端代理**

   - 开发阶段用 webpack / Vite dev server 配置代理，把跨域请求转发到后端。

   - 浏览器看到的是同源请求，跨域问题被绕过。

     <img src="C:\Users\wyy65\Documents\clinet_study\前端学习笔记\image\444.jpg" alt="444" />

3. **JSONP**（仅支持 GET）

   - 利用 `<script>` 标签不受跨域限制，但现代项目基本不用了。

4. **浏览器插件或 Nginx 转发**

   - 开发阶段可临时使用浏览器插件绕过

   - 生产环境用 Nginx 反向代理后端接口

     

------

💡 总结判断：

| 来源           | 请求          | 同源/跨域 |
| -------------- | ------------- | --------- |
| 前端页面服务器 | 请求前端 JSON | 同源      |
| 前端页面服务器 | 请求后端接口  | 跨域      |

------

【同源请求】
浏览器页面 (前端服务器)
        |
        | fetch 请求前端 JSON
        v
   前端服务器 (同源)
        |
        | 返回数据
        v
   浏览器页面成功获取数据

----------------------------------------

【跨域请求】
浏览器页面 (前端服务器)
        |
        | fetch 请求后端接口 (不同域名/端口)
        v
   浏览器拦截 (跨域)
        |
        | 需要 CORS 或前端代理处理
        v
   后端服务器返回数据 -> 浏览器接收



## 单个导出（Named Export）

### 📂 文件结构

```
project/
 ├── index.html
 ├── main.js
 └── 1.js
```

------

### 1.js

```js
// 1.js
export const a = 1;

export function b() {
  return "我是函数 b";
}

export class c {
  sayHi() {
    console.log("Hi，我是类 c 的实例方法");
  }
}
```

------

### main.js

```js
// main.js
import { a, b, c } from './1.js';

console.log(a);       // 1
console.log(b());     // 我是函数 b
new c().sayHi();      // Hi，我是类 c 的实例方法
```

------

### index.html

```js
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>ES Module Demo</title>
</head>
<body>
  <h2>ES Module 导入导出示例</h2>
  
  <!-- 必须加 type="module" -->
  <script type="module" src="./main.js"></script>
</body>
</html>
```





## 1. 命名导出（Named Export）

### 写法 A：单独导出

```js
// utils.js
export const a = 1;
export function b() {
  return "函数 b";
}
export class c {
  sayHi() {
    console.log("Hi from c");
  }
}
```

### 写法 B：统一导出

```js
// utils.js
const a = 1;
function b() {
  return "函数 b";
}
class c {
  sayHi() {
    console.log("Hi from c");
  }
}

export { a, b, c };
```

👉 导入时必须 **解构花括号**

```js
import { a, b, c } from './utils.js';

console.log(a);   // 1
console.log(b()); // 函数 b
new c().sayHi();  // Hi from c
```

------

## 2. 默认导出（Default Export）

每个模块只能有 **一个 default**。

```js
// utils.js
export default function() {
  console.log("我是默认导出");
}
```

👉 导入时 **不需要花括号**，名字可自定义：

```js
import myFunc from './utils.js';

myFunc(); // 我是默认导出
```

------

## 3. 混合导出（默认 + 命名）

```js
// utils.js
export const a = 1;
export function b() { return "b"; }
export default class {
  sayHi() {
    console.log("我是默认导出的类");
  }
}
```

👉 导入时：

```js
import DefaultClass, { a, b } from './utils.js';

console.log(a);    // 1
console.log(b());  // b
new DefaultClass().sayHi();  // 我是默认导出的类
```

------

## 4. 整体导入（namespace import）

```js
// utils.js
export const a = 1;
export const b = 2;
export default 999;
```

👉 导入时：

```js
import * as utils from './utils.js';

console.log(utils.a);       // 1
console.log(utils.b);       // 2
console.log(utils.default); // 999
```

------

📝 总结：

- **命名导出**：`export { a, b, c }` → `import { a, b, c }`
- **默认导出**：`export default ...` → `import 任意名字`
- **混合导出**：`export default ...; export { a, b }`
- **整体导入**：`import * as obj from '...'`
